import Numbers
import Add
import Sub

assume fn mult(Complex, Complex)

assume ide Commute(Complex a, Complex b)
    mult(a,b)=mult(b,a);

assume ide Associate(Complex a, Complex b, Complex c)
    mult(mult(a,b),c)=mult(a,mult(b,c));

assume ide IdentityRight(Complex a)
    mult(a,1)=a

prove ide IdentityLeft(Complex a) {
    let 2 mult(1,a)
    substitute Commute:1
    substitute IdentityRight:1
} result {
    mult(1,a)=a
}

assume ide Distribute(Complex f, Complex a, Complex b)
    mult(f,add(a,b))=add(mult(f,a),mult(f,b));

prove ide DistributeRight(Complex a, Complex b, Complex c) {
    let 2 mult(add(a,b),c)
    substitute Commute:1
    substitute Distribute:1
    substitute Commute:1,[0|1]
} result {
    mult(add(a,b),c)=add(mult(a,c),mult(b,c))
}

prove ide OuterCommute(Complex a, Complex b, Complex c) {
    let 2 mult(mult(a,b),c)
    substitute Associate:1
    substitute Commute:1,1
    substitute ~Associate:1
} result {
    mult(mult(a,b),c)=mult(mult(a,c),b)
}

prove ide DistributeSub(Complex f, Complex a, Complex b) {
    let 2 sub(mult(f,a),mult(f,b));
    substitute ~Sub.AddSub(-,b):0,0,1;
    substitute Distribute:0,0;
    substitute Sub.SubAdd:0;
} result {
    mult(f,sub(a,b))=sub(mult(f,a),mult(f,b))
}

prove ide Singularity(Complex a) {
    let 3 0;
    substitute ~Sub.Inverse(a):[1|2];
    substitute ~IdentityRight:[1,[0|1]|2,[0|1]];
    substitute ~DistributeSub:[1|2];
    substitute Sub.Inverse:[1,1|2,1];
    substitute Commute:1;
} result {
    0=mult(0,a)=mult(a,0)
}

prove ide NegAsMult(Complex a) {
    let 3 sub(0,a);
    substitute Singularity[0->2](a):[1,0|2,0];
    substitute ~IdentityRight:[1,1|2,1];
    substitute ~DistributeSub:[1|2];
    substitute Commute:1;
} result {
    sub(0,a)=mult(sub(0,1),a)=mult(a,sub(0,1))
}
