import Numbers
import Add
import Sub

assume fn mult(Complex, Complex)

assume Commute(Complex a, Complex b)
    mult(a,b)=mult(b,a);

assume Associate(Complex a, Complex b, Complex c)
    mult(mult(a,b),c)=mult(a,mult(b,c));

assume IdentityRight(Complex a)
    mult(a,1)=a

work IdentityLeft(Complex a) {
    let 2 mult(1,a)
    substitute Commute:1
    substitute IdentityRight:1
} result {
    mult(1,a)=a
}

assume Distribute(Complex f, Complex a, Complex b)
    mult(f,add(a,b))=add(mult(f,a),mult(f,b));

work DistributeRight(Complex a, Complex b, Complex c) {
    let 2 mult(add(a,b),c)
    substitute Commute:1
    substitute Distribute:1
    substitute Commute:1,[0|1]
} result {
    mult(add(a,b),c)=add(mult(a,c),mult(b,c))
}

work OuterCommute(Complex a, Complex b, Complex c) {
    let 2 mult(mult(a,b),c)
    substitute Associate:1
    substitute Commute:1,1
    substitute ~Associate:1
} result {
    mult(mult(a,b),c)=mult(mult(a,c),b)
}

work DistributeSub(Complex f, Complex a, Complex b) {
    let 2 sub(mult(f,a),mult(f,b));
    substitute ~Sub.AddSub(-,b):0,0,1;
    substitute Distribute:0,0;
    substitute Sub.SubAdd:0;
} result {
    mult(f,sub(a,b))=sub(mult(f,a),mult(f,b))
}

work Singularity(Complex a) {
    let 3 0;
    substitute ~Sub.Inverse(a):[1|2];
    substitute ~IdentityRight:[1,[0|1]|2,[0|1]];
    substitute ~DistributeSub:[1|2];
    substitute Sub.Inverse:[1,1|2,1];
    substitute Commute:1;
} result {
    0=mult(0,a)=mult(a,0)
}

work NegAsMult(Complex a) {
    let 3 sub(0,a);
    substitute Singularity[0->2](a):[1,0|2,0];
    substitute ~IdentityRight:[1,1|2,1];
    substitute ~DistributeSub:[1|2];
    substitute Commute:1;
} result {
    sub(0,a)=mult(sub(0,1),a)=mult(a,sub(0,1))
}
