import Numbers
import Add

assume fn sub(Complex, Complex)

assume AddSub(Complex a, Complex b)
    add(sub(a,b),b)=a

assume SubAdd(Complex a, Complex b)
    sub(add(a,b),b)=a

work IdentityRight(Complex a) {
    let 2 sub(a,0);
    substitute ~Add.IdentityRight:1,0;
    substitute SubAdd(-,0):1;
} result {
    sub(a,0)=a
}

work Inverse(Complex a) {
    let 2 0;
    substitute ~SubAdd(-,a):0;
    substitute Add.IdentityLeft:0,0;
} result {
    sub(a,a)=0
}

work AsAdd(Complex a, Complex b) {
    let 2 sub(a,b);
    substitute ~Add.IdentityRight:1,0;
    substitute ~AddSub(-,b):1,0,1;
    substitute ~Add.Associate:1,0;
    substitute SubAdd:1;
} result {
    sub(a,b)=add(a,sub(0,b))
}

work Commute(Complex a, Complex b, Complex c) {
    let 3 sub(sub(a,b),c);
    substitute AsAdd:1;
    substitute AsAdd:1,0;
    substitute Add.OuterCommute:1;
    substitute ~AsAdd:1,0;
    substitute ~AsAdd:1;

    substitute ~AddSub(-,add(b,c)):2,0,0;
    substitute Add.Commute:2,0,0,1;
    substitute ~Add.Associate:2,0,0;
    substitute SubAdd:2,0;
    substitute SubAdd:2;
} result {
    sub(sub(a,b),c)=sub(sub(a,c),b)=sub(a,add(b,c))
}

work Commute2(Complex a, Complex b, Complex c) {
    let 4 sub(add(a,b),c);
    substitute AsAdd:[1|2|3];
    substitute Add.Associate:1;
    substitute Add.OuterCommute:[2|3];
    substitute ~AsAdd:[1,1|2,0|3,0];

    substitute ~AddSub(-,b):3,0,1;
    substitute Commute[2->0]:3,0;
    substitute AddSub(-,b):3;
} result {
    sub(add(a,b),c)=add(a,sub(b,c))=add(sub(a,c),b)=sub(a,sub(c,b))
}

work Negate(Complex a) {
    let 2 a;
    substitute ~SubAdd(-,0):1;
    substitute Add.Commute:1,0;
    substitute Commute2[0->3]:1;
} result {
    a=sub(0,sub(0,a))
}