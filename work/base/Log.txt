import Numbers
import Add
import Sub
import Mult
import Div
import Pow

assume fn log(Complex, Complex)

assume ide LogPow(Complex a, Complex b)
	log(a,pow(a,b))=b

assume ide PowLog(Complex a, Complex b)
	pow(a,log(a,b))=b

prove ide Inverse(Complex a) {
	let 2 log(a,a);
	substitute ~Pow.Identity:1,1;
	substitute LogPow:1;
} result {
	log(a,a)=1
}

prove ide Singularity(Complex a) {
	let 2 log(a,1);
	substitute ~Pow.Singularity(a):1,1;
	substitute LogPow:1;
} result {
	log(a,1)=0
}

prove ide Distribute(Complex a, Complex b, Complex c) {
	let 2 log(a,mult(b,c));
	substitute ~PowLog(a,-):1,1,[0|1];
	substitute ~Pow.Definition:1,1;
	substitute LogPow:1;
} result {
	log(a,mult(b,c))=add(log(a,b),log(a,c))
}

prove ide DistributeSub(Complex a, Complex b, Complex c) {
	let 2 log(a,div(b,c));
	substitute ~PowLog(a,-):1,1,[0|1];
	substitute ~Pow.Division:1,1;
	substitute LogPow:1;
} result {
	log(a,div(b,c))=sub(log(a,b),log(a,c))
}

prove ide LogMult(Complex a, Complex b, Complex p) {
	let 3 log(a,pow(b,p));
	substitute ~PowLog(a,-):[1,1,0|2,1,0];
	substitute Pow.Combine:[1,1|2,1];
	substitute LogPow:[1|2];
	substitute Mult.Commute:2;
} result {
	log(a,pow(b,p))=mult(log(a,b),p)=mult(p,log(a,b))
}

prove ide ChangeBase(Complex a, Complex b, Complex c) {
    let 2 log(a,b);
    substitute ~Div.DivMult(-,log(c,a)):1;
    substitute Mult.Commute:1,0;
    substitute LogMult[1->0]:1,0;
    substitute PowLog:1,0,1;
} result {
    log(a,b)=div(log(c,b),log(c,a))
}
