import Numbers
import Add
import Sub
import Mult
import Div

assume fn pow(Complex, Complex)

assume ide Definition(Complex a, Complex n, Complex m)
    pow(a,add(n,m))=mult(pow(a,n),pow(a,m));

assume ide Distribute(Complex a, Complex b, Complex n)
    pow(mult(a,b),n)=mult(pow(a,n),pow(b,n));

assume ide Identity(Complex a)
    pow(a,1)=a;

assume ide Combine(Real a, Complex n, Complex m)//[a>0]
    pow(pow(a,n),m)=pow(a,mult(n,m));

prove ide Division(Complex a, Complex n, Complex m) {
    let 2 div(pow(a,n),pow(a,m));
    substitute ~Sub.AddSub(-,m):0,0,1;
    substitute Definition:0,0;
    substitute Div.DivMult:0;
} result {
    pow(a,sub(n,m))=div(pow(a,n),pow(a,m))
}

prove ide Singularity(Complex a) {
    let 2 pow(a,0);
    substitute ~Sub.Inverse(1):1,1;
    substitute Division:1;
    substitute Div.Inverse:1;
} result {
    pow(a,0)=1
}

prove ide Singularity2(Complex a) {
    let 2 pow(0,a);
    substitute ~Sub.AddSub(-,1):1,1;
    substitute Definition:1;
    substitute Identity:1,1;
    substitute Mult.Singularity[2->0]:1;
} result {
    pow(0,a)=0
}

inductive ide CombineInt(Complex a, Complex n, Integer m) {
    base m=1 {
        let 2 pow(a,n)
        substitute ~Identity:0
        substitute ~Mult.IdentityRight:1,1
    } m -> add(m,1) {
        call x mult(x,pow(a,n))
        substitute ~Identity:0,1
        substitute ~Definition:[0|1]
        substitute ~Mult.IdentityRight:1,1,1
        substitute ~Mult.Distribute:1,1
    } m -> sub(m,1) {
        call x div(x,pow(a,n))
        substitute ~Identity:0,1
        substitute ~Division:[0|1]
        substitute ~Mult.IdentityRight:1,1,1
        substitute ~Mult.DistributeSub:1,1
    }
} result {
    pow(pow(a,n),m)=pow(a,mult(n,m))
}