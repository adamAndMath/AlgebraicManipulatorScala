import Numbers
import base.Add
import base.Sub
import base.Mult
import base.Div
import base.Pow
import base.Log
import Euler
using base.Log

define fn ln(Complex a) = log(e, a);

work LnPow(Complex a) {
    let 2 ln(pow(e,a))
	unwrap:1
	substitute Log.LogPow(e,-):1
} result {
	ln(pow(e,a))=a
}

work PowLn(Complex a) {
	let 3 pow(e,ln(a))
	unwrap:1,1
	substitute Log.PowLog(e,-):1
} result {
	pow(e,ln(a))=a
}

work Inverse() {
	let 2 ln(e)
	unwrap:1
	substitute Log.Inverse:1
} result {
	ln(e)=1
}

work Singularity() {
	let 2 ln(1)
	unwrap:1
	substitute Log.Singularity:1
} result {
	ln(1)=0
}

work Distribute(Complex a, Complex b) {
	let 2 log(e,mult(a,b))
	substitute Log.Distribute:1
	wrap ln:[0|1,[0|1]]
} result {
	ln(mult(a,b))=add(ln(a),ln(b))
}

work DistributeSub(Complex a, Complex b) {
	let 2 log(e,div(a,b))
	substitute Log.DistributeSub:1
	wrap ln:[0|1,[0|1]]
} result {
	ln(div(a,b))=sub(ln(a),ln(b))
}

work LnMult(Complex a, Complex p) {
	let 3 log(e,pow(a,p))
	substitute Log.LogMult[0->1]:1
	substitute Log.LogMult[0->2]:2
	wrap ln:[0|1,0|2,1]
} result {
	ln(pow(a,p))=mult(ln(a),p)=mult(p,ln(a))
}

work ChangeBase(Complex a, Complex b) {
    let 2 log(a,b)
    substitute Log.ChangeBase(-,-,e):1
    wrap ln:1,[0|1]
} result {
    log(a,b)=div(ln(b),ln(a))
}